@@@title:<七周七并发模型>笔记
@@@date:2015-12-16

tags:
---
chp2
===
共享变量解决冲突
----
**加锁**

**多个共享资源**
加多个锁,但加多个锁必然可能导致死锁

**死锁**
保证上锁顺序

**外星方法**
即调用者不知道其实现的方法

问题:如果调用者已经加锁,再调用外星方法,这个方法如果有锁,就很有可能死锁,解决方法是调用方法前对调用者进行一次保护性复制(对象),然后在进行调用

解决死锁
---
**使用ReentrantLock**
锁有超时事件,超时会放弃所拥有的锁

但是这样并不能完全解决死锁问题,这种方案会产生活锁现象,当所有死锁同时超时,那么下次再获得锁时,很有可能会继续死锁

通过设置不同的超时事件可以减少活锁的概念

###交替锁

###条件锁

###原子变量
atomic包

###自学内容
###公平锁与非公平锁
公平锁: 线程按照先来后到的方式获取锁
非公平: 线程竞争,没获取到锁的线程会被压进队列,但是,压进队列的线程依旧会被后到的线程抢到锁

公平锁和非公平锁的区别是性能,非公平锁的性能回事公平锁的5~10倍
(数据来源: http://www.majin163.com/2014/03/17/synchronized2/)

###虚假唤醒(spurious wakeup)
就算没人调用signal,await还是有可能会被调用

所以用while等待条件满足唤醒,就算被虚假唤醒了,因为要判断一次条件,所以也能避免虚假唤醒造成的问题

###为什么synchronize比reentrantlock慢
因为syn是悲观锁,reentrantlock是乐观锁
>独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低
http://blog.csdn.net/natian306/article/details/18504111


最佳方案
==
使用线程池
---
实际使用中极少会直接创建线程

线程池大小?

生产者消费者模型
---
使用并行提高效率

eg.1 统计wiki词频, 串行实现,花费105s

eg.2 使用生产者消费者模型,将程序拆分为解析单词(生产者)和统计单词(消费者),二者共用一个队列(阻塞队列), 结果95s

eg.3 由上面例子统计显示,解析花费了10秒,那么统计就花费了95秒(最终时间其实是二者最大值), 所以可以想办法提高统计速度,最为简单的方法是增加消费者

然而现实是残酷的,因为多个消费者要共享一个currentCount, 结果是等待锁和获取锁的开销比统计本身还要大,所以性能反而下降了

eg.4 那么可以使用java.util.concurrent的ConcurrentHashMap,它提供了原子的读写改方法,还使用了锁分段

但是这时的性能依然不够好,使用多个消费者却没有达到理论上的多倍性能

eg.5 性能比理论低很大原因是count还有冲突,那么我们可以对每个消费者都建一个count,然后最后将他们相加起来

总结:
如果要提高性能
1.尽量用原子操作
2.减少锁竞争和冲突 使用ConcurrentHashMap
3.线程池
4.使用ArrayBlockingQueue让消费者生产者更高效

规律:
性能会随着线程数上升,而先上升后下降

自习
---
我先跳过
Fork/Join
work-stealing
CountDownLatch, CyclicBarrier
adahl's law
毒丸方法
核心与线程数关系

优点&缺点
---
线程与锁模型
优点: 快!实用性强!
缺点: 使用难度高,难调试,难维护,bug莫名其妙,有单元测试也很难重构

只能用log记录尽量多的信息来排bug

Chp3 函数式编程
====
抛弃可变状态
---
可变状态的隐藏和逃逸
隐藏: 函数本身不是线程安全的
逃逸: 返回了"线程不安全的对象", 比如返回iterator(), 如果遍历时,链表被修改, 那么iterator就会返回错误

懒惰序列

用性能换健壮性



